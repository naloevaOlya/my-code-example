# -*- coding: utf-8 -*-
"""SMVM_lab_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gA3GkdlCav4n6X3otCDq2XaolD6rrxKr
"""

import numpy as np
import matplotlib.pyplot as plt
import time as time
import copy
import timeit
import pandas as pd

N_num = 1
K_num = 6
l = 1

def monom(n, x):
    return x**n

def poly_approx(c, x, N, K):
    res = 0
    k = int(np.floor(x/(l/K)))
    h = l/K/2
    for i in range(N+1):
        res += c[k*(N+1)+i] * ((x - 2*k*h-h)/h)**i
    return res

def p_diff(x, power, diff_power):
    res = 1
    if power < diff_power:
        return 0
    for i in range(diff_power):
        res *= power
        power -= 1
    res *= x**power
    return res

def rotation_vec(x):
    e = np.zeros(len(x))
    e[0] = 1
    rot_vec_1 = x + np.sqrt(x.dot(x)) * e
    rot_vec_2 = x - np.sqrt(x.dot(x)) * e
    if rot_vec_1.dot(rot_vec_1) > rot_vec_2.dot(rot_vec_2):
        rot_vec = rot_vec_1
    else:
        rot_vec = rot_vec_2
    rot_vec = rot_vec / np.sqrt(rot_vec.dot(rot_vec))
    return rot_vec

def housholder(A):   
  Q = np.eye(A.shape[0])
  R = copy.deepcopy(A)
  for i in range(min(A.shape)):
        u = rotation_vec(R[i:, i])
        Q_i = np.eye(A.shape[0])
        Q_i[i:, i:] -= 2.0 * np.outer(u, u)
        R = np.dot(Q_i, R)  # R=H(n-1)*...*H(2)*H(1)*A
        Q = np.dot(Q, Q_i)  # Q = H (N-1) * ... * H (2) * H (1) H 
  return Q, R

def solve(R, b):
    len = min(R.shape)
    x = np.zeros(len)
    for i in range(len-1, -1, -1):
        for j in range(len-1, -1, -1):
            if i!=j:
                b[i] -= b[j] * R[i,j] / R[j,j]
        x[i] = b[i] / R[i,i]
    return x

def plotting(x, data, approximation, ind):
    SIZE = 12
    fig, (ax) = plt.subplots(1)
    ax.plot(x , data)
    ax.plot(x, np.transpose(approximation), linestyle = '--')

    ax.legend(['Аппроксимация K='+str(K), 'Точное решение'])
    ax.set_xlabel('x', fontsize = SIZE)
    ax.set_ylabel('y', fontsize = SIZE)
    plt.show()

def f_collocation_points(N):
    points = np.zeros(N+1)
    h = 2/(N+1)
    points[0] = -1 + h/2
    for i in range(1, N+1):
        points[i] = points[i-1] + h
    return points

def collocation_row(collocation_point, k_c, N, h):
    row = np.zeros(N+1)
    for n in range(N+1):
        row[n] = k_c * p_diff(collocation_point, n, 4) / (h**4)
    return row

def f(x):
    return np.exp(x)*(x**4 + 14*(x**3) + 49*(x**2) + 32*x - 12)

def w_exact(x):
    return np.exp(x) * (x**2) * ((1-x)**2)

def g_1(x):
    return 0
def g_2(x):
    return 0

def y_to_x(y, k, K):
    h = l/K
    return h*(k+0.5*(1 + y))

def matching_rows(y, k_b, k_m, N, border = False, right_side = False):
    row = np.zeros((2,N+1))

    if border:
        for i in range(N+1):
            row[0, i] = p_diff(x=y, power=i, diff_power=0)
            row[1, i] = p_diff(x=y, power=i, diff_power=1) / h
        row[0] *= k_b[0]
        row[1] *= k_b[1]
    elif right_side:
        for i in range(N+1):
            row[0, i] = k_m[0] * p_diff(x=y, power=i, diff_power=0) -\
                y*k_m[1]/h * p_diff(x=y, power=i, diff_power=1)
            row[1, i] = k_m[2]/(h**2) * p_diff(x=y, power=i, diff_power=2) -\
                y*k_m[3]/(h**3) * p_diff(x=y, power=i, diff_power=3)
    else:
        for i in range(N+1):
            row[0, i] = k_m[0] * p_diff(x=y, power=i, diff_power=0) +\
                y*k_m[1]/h * p_diff(x=y, power=i, diff_power=1)
            row[1, i] = k_m[2]/(h**2) * p_diff(x=y, power=i, diff_power=2) +\
                y*k_m[3]/(h**3) * p_diff(x=y, power=i, diff_power=3)
    return row

def A(collocation_points, k_c, k_b, k_m, N, h, left_border = False, right_border = False):
    A = np.zeros((N+5, N+1))
    for j in range(N+1):
        A[j] = collocation_row(collocation_points[j], k_c, N, h)
    A[N+1:N+3] = matching_rows(-1,k_b, k_m,N, border = left_border)
    A[N+3:N+5] = matching_rows(1,k_b, k_m,N, border = right_border)
    return A

def b(collocation_points, k, k_b):
    b = np.zeros(N+5)
    
    for j in range(N+1):
        b[j] = k_c * f(y_to_x(collocation_points[j], k=k, K=K))
    
    if k==0:
        b[N+1:N+3] = np.array([k_b[0] * g_1(0), k_b[1] *  g_2(0)])
    else:
        b[N+1:N+3] = np.array([0,0]) # matching_rows(y=1, right_side=True).dot(c[k-1])

    if k==(K-1):
        b[N+3:N+5] = np.array([k_b[0] * g_1(l), k_b[1] *  g_2(l)])
    else:
        b[N+3:N+5] = np.array([0,0]) # matching_rows(y=-1, right_side=True).dot(c[k+1])
    return b

def errors(num_of_points, c, N, K):
    points = f_collocation_points(num_of_points)
    mmax = 0
    mmax_sol = 0
    for k in range(K):
        for num in range(num_of_points):
            err = abs(poly_approx(c, y_to_x(points[num], k, K), N, K) \
                      - w_exact(y_to_x(points[num], k,K)))
            mmax = max(err, mmax)
            mmax_sol = max(w_exact(y_to_x(points[num], k,K)), mmax_sol)
    abs_err = mmax
    rel_err = abs_err / mmax_sol
    return abs_err, rel_err

time_table = np.zeros((N_num,K_num))
A_cond = np.zeros((N_num,K_num))
abs_error_tab = np.zeros((N_num,K_num))
rel_error_tab = np.zeros((N_num,K_num))

conv_rate_N = np.zeros((N_num,K_num))
conv_rate_K = np.zeros((N_num,K_num))
rel_conv_rate_K = np.zeros((N_num,K_num))

for n_index in range(1):
    N = 5
    for k_index in range(K_num):
        K = 5 * 2**(k_index)
        h = l/K/2
        k_c = h**4
        k_m = [1, h, h**2, h**3]
        k_b = [1, h]

        start_time = time.time()
        
        c = np.ones(K*(N+1)) * 0.4
        collocation_points = f_collocation_points(N)
        
        A_ = np.zeros((K*(N+5), K*(N+1)))
        b_ = np.zeros(K*(N+5))
        
        A_[:N+5, :N+1] = A(collocation_points,k_c,k_b,k_m,N, h, left_border=True)
        A_[N+3:N+5, N+1:2*(N+1)] = -matching_rows(-1,k_b,k_m,N, right_side=True)
        
        A_[-N-5:, -N-1:] = A(collocation_points,k_c,k_b,k_m,N, h, right_border=True)
        A_[-4:-2, 2*(-N-1):(-N-1)] = -matching_rows(1,k_b,k_m,N, right_side=True)
        
        for k in range(1, K-1):
            A_[k*(N+5):(k+1)*(N+5), k*(N+1):(k+1)*(N+1)] = A(collocation_points, k_c,k_b,k_m,N, h,)
            A_[k*(N+5) + N+1:k*(N+5) + N+3, (k-1)*(N+1):k*(N+1)] = -matching_rows(1,k_b,k_m,N, right_side = True)
            A_[k*(N+5) + N+3:k*(N+5) + N+5, (k+1)*(N+1):(k+2)*(N+1)] = -matching_rows(-1,k_b,k_m,N, right_side = True)
            
        for k in range(K):
            b_[k*(N+5):(k+1)*(N+5)] = b(collocation_points, k, k_b)
        
        A_cond[n_index,k_index] = np.linalg.cond(A_)
        
        Q, R = housholder(A_)
        b_ = np.transpose(Q).dot(b_)
        
        c = solve(R, b_)
        
        end_time = time.time()
        
        time_table[n_index, k_index] = end_time - start_time
        abs_error_tab[n_index,k_index], rel_error_tab[n_index,k_index] = errors(100, c, N, K)
        if n_index > 0:
            conv_rate_N[n_index,k_index] = np.log(abs_error_tab[n_index-1,k_index] \
                                                  / abs_error_tab[n_index,k_index]) / np.log(2)
        if k_index > 0:
            conv_rate_K[n_index,k_index] = np.log(abs_error_tab[n_index,k_index-1] \
                                                  / abs_error_tab[n_index,k_index]) / np.log(2)
            rel_conv_rate_K[n_index,k_index] = np.log(rel_error_tab[n_index,k_index-1] \
                                                  / rel_error_tab[n_index,k_index]) / np.log(2)

        length = 5000
        x = np.linspace(0,l,length, False)
        approx = np.zeros(length)
        real = np.zeros(length)
        
        for i in range(length):
            approx[i] = poly_approx(c, x[i], N, K)
            real[i] = w_exact(x[i])
        plotting(x, real, approx, K)

data = [abs_error_tab[0], conv_rate_K[0], rel_error_tab[0],rel_conv_rate_K[0], A_cond[0], time_table[0]]
pd.set_option("precision", 2)
df = pd.DataFrame(np.transpose(data))
df.to_csv('out.csv')

df

c