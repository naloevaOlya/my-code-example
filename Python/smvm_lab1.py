# -*- coding: utf-8 -*-
"""first_lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pJQ08CZJqpnh-ra7oJaf5zcKHK70p5cb
"""

import numpy as np
import matplotlib.pyplot as plt
import time as time
import copy

N_max = 10
data_indexes = [1,4,5]
time_LS = np.zeros(N_max)
time_QR = np.zeros(N_max)
error_LS = np.zeros(N_max)
error_QR = np.zeros(N_max)
cond_LS = np.zeros(N_max)
cond_QR = np.zeros(N_max)

def Legendre_polynomials(n,x):
  if n == 0: return 1
  if n == 1: return x
  if n > 1: return ((2*n+1)/(n+1))*x*Legendre_polynomials(n-1,x)-(n/(n-1))*Legendre_polynomials(n-2,x)

def bas_matrix(data_len,data,N):
  res = np.zeros((N+1, data_len))
  for i in range(N+1):
    for j in range(data_len):
      res[i,j] = Legendre_polynomials(i, data[j,0])
  return res

def expanded(data_len,data,N, A):
  result = np.zeros((data_len + N+1, data_len + N+1))
  result[:data_len, :data_len] = np.eye(data_len)
  result[data_len:, :data_len] = A
  result[:data_len, data_len:] = np.transpose(A)
  return result

def y_coordinates(data_len,data,N):
  res = np.zeros(data_len + N+1)
  res[:data_len] = data[:, 1]
  return res

def approx(c, n, x):
    res = 0
    for i in range(n+1):
        res += c[i] * Legendre_polynomials(i, x)
    return res

def solve(R, b):
    len = min(R.shape)
    x = np.zeros(len)
    for i in range(len-1, -1, -1):
        for j in range(len-1, -1, -1):
            if i!=j:
                b[i] -= b[j] * R[i,j] / R[j,j]
        x[i] = b[i] / R[i,i]
    return x

def rotation_vec(x):
    e = np.zeros(len(x))
    e[0] = 1
    rot_vec_1 = x + np.sqrt(x.dot(x)) * e
    rot_vec_2 = x - np.sqrt(x.dot(x)) * e
    if rot_vec_1.dot(rot_vec_1) > rot_vec_2.dot(rot_vec_2):
        rot_vec = rot_vec_1
    else:
        rot_vec = rot_vec_2
    rot_vec = rot_vec / np.sqrt(rot_vec.dot(rot_vec))
    return rot_vec

def housholder(A):   
  Q = np.eye(A.shape[0])
  R = copy.deepcopy(A)
  for i in range(min(A.shape)):
        u = rotation_vec(R[i:, i])
        Q_i = np.eye(A.shape[0])
        Q_i[i:, i:] -= 2.0 * np.outer(u, u)
        R = np.dot(Q_i, R)  # R=H(n-1)*...*H(2)*H(1)*A
        Q = np.dot(Q, Q_i)  # Q = H (N-1) * ... * H (2) * H (1) H 
  return Q, R

def compute(data_len, data, approximation_LS, approximation_QR):
  for N in range(N_max):
        time_start = time.time()
        A = bas_matrix(data_len,data,N)
        A_expanded = expanded(data_len,data,N,A)
        b = y_coordinates(data_len,data,N)
        c = np.linalg.solve(A_expanded, b)[data_len:]
        for i in range(data_len):
            approximation_LS[N, i] = approx(c, N, data[i, 0])
        time_end = time.time()
        time_LS[N] = time_end - time_start
        
        time_start = time.time()
        Q, R = housholder(np.transpose(A))
        b = np.transpose(Q).dot(data[:,1])
        c = solve(R[:N+1,:N+1], b[:N+1])
        for i in range(data_len):
            approximation_QR[N, i] = approx(c, N, data[i, 0])
        time_end = time.time()
        time_QR[N] = time_end - time_start
        
        cond = np.linalg.cond(A)
        cond_LS[N] = cond ** 2
        cond_QR[N] = cond

def error(data, approximation):
    error = data - approximation
    res = np.zeros(len(approximation))
    for i in range(len(approximation)):
        res[i] = np.sqrt(error[i].dot(error[i]) / len(error[0])) / max(data)
    return res

def plotting(data, approximation, iter):
    SIZE = 12
    fig, (ax) = plt.subplots(1)
    ax.plot(data[:,0], np.transpose(approximation), linestyle = '--')
    ax.plot(data[:,0] , data[:, 1])
    labels = list(range(len(approximation)))
    for i in range(len(approximation)):
        labels[i] = 'Аппроксимация N=' + str(labels[i])
    ax.legend((labels) + ['Данные ' + str(iter)])
    ax.set_xlabel('x', fontsize = SIZE)
    ax.set_ylabel('y', fontsize = SIZE)
    plt.show()

result = open('output.csv', 'w')
for iter in data_indexes:
    print(iter)
    data = np.loadtxt('data_' + str(iter) + '.txt',dtype='float')
    data_len = len(data[:,0])
    approximation_LS = np.zeros((N_max, data_len))
    approximation_QR = np.zeros((N_max, data_len))
    compute(data_len, data, approximation_LS, approximation_QR)

    error_LS = error(data[:,1], approximation_LS)
    error_QR = error(data[:,1], approximation_QR)
    plotting(data, approximation_LS, iter)
    plotting(data, approximation_QR, iter)
    for N in range(N_max):
      result.write(str(N) + ',' + '{:.2e}'.format(cond_LS[N]) + \
                 ',' + '{:.2e}'.format(cond_QR[N]) + ',' + \
                 '{:.2e}'.format(error_LS[N]) + ',' + \
                 '{:.2e}'.format(error_QR[N]) + ',' + \
                 '{:.2e}'.format(time_LS[N]) + ',' + \
                 '{:.2e}'.format(time_QR[N]) + '\n')
result.close()

